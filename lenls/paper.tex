% This is LLNCS.DEM the demonstration file of
% the LaTeX macro package from Springer-Verlag
% for Lecture Notes in Computer Science,
% version 2.4 for LaTeX2e as of 16. April 2010
%
\documentclass{llncs}
%
\usepackage{makeidx}

\usepackage{caption}
\usepackage[labelformat=simple]{subcaption}
\renewcommand\thesubfigure{(\alph{subfigure})}

\usepackage[utf8]{inputenc}
\usepackage{amsmath}
%\usepackage{amsthm}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{gb4e}
\usepackage{bussproofs}
\usepackage{hyperref}
\usepackage{cancel}
\usepackage{pdfpages}
\usepackage{enumitem}

%% Linear implication from Alessio Guglielmi
%% https://groups.google.com/forum/?fromgroups=#!topic/comp.text.tex/0B4C3F_BsVI
\def\limp {\mathbin{{-}\mkern-3.5mu{\circ}}}

%
\begin{document}
%
\frontmatter          % for the preliminaries
%
\pagestyle{headings}  % switches on printing of running heads

\mainmatter              % start of the contributions
%
\title{Integration of Multiple Constraints in ACG}
%
\titlerunning{Constraints in ACG}  % abbreviated title (for running head)
%                                    also used for the TOC unless
%                                    \toctitle is used
%
\author{Jiří Maršík\inst{1,2} \and Maxime Amblard\inst{2}}
%
\authorrunning{Maršík et al.} % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
\tocauthor{Jiří Maršík and Maxime Amblard}
%
\institute{Université de Lorraine, LORIA, Nancy, 54000, France\\
\email{\{jiri.marsik, maxime.amblard\}@loria.fr},\\
\and
INRIA, Nancy, 54000, France}

\maketitle              % typeset the title of the contribution

\begin{abstract}
This proposal is a first step towards a wide-coverage Abstract Categorial
Grammar (ACG) that could be used to automatically build discourse-level
representations. We focus on the challenge of integrating the treatment of
disparate linguistic constraints in a single ACG and propose a generalization
of the formalism: Graphical Abstract Categorial Grammars.
\keywords{abstract categorial grammars, grammar engineering, grammatical formalisms, formal grammars, computational linguistics}
\end{abstract}


\section{Motivation}

Abstract Categorial Grammars (ACGs) have shown to be a viable formalism for
elegantly encoding the dynamic nature of discourse. Proposals based on
continuation semantics \cite{de2006towards} have tackled topics such as event
anaphora \cite{qian2011event}, SDRT discourse structure \cite{asher2011sdrt}
and modal accessibility constraints \cite{asher2011montagovian}. However, all
of these treatments only consider tiny fragments of languages. We are
interested in building a wide-coverage grammar which integrates and reconciles
the existing formal treatments of discourse and allows us to study their
interactions and to build discourse representations automatically.

In this paper, we focus on the problem of constructing a wide-coverage ACG. We
identify a problem that comes up when one tries to enforce multiple
constraints/dependencies in a single ACG and we propose a generalization of
the formalism which resolves the issue.


\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{0.25\textwidth}
    \centering
    \includegraphics[height=0.2\textheight]{../diagrams/double-acg.pdf}
    \caption{\label{fig:acg-comp-basic} Connecting form with meaning.}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{0.25\textwidth}
    \centering
    \includegraphics[height=0.2\textheight]{../diagrams/serial-over-parallel.pdf}
    \caption{\label{fig:acg-comp-constr} Adding a constraint.}
  \end{subfigure}
  \qquad
  \begin{subfigure}[b]{0.25\textwidth}
    \centering
    \includegraphics[height=0.2\textheight]{../diagrams/parallel-over-serial.pdf}
    \caption{\label{fig:acg-comp-sem} Distinguishing syntactic and
      semantic ambiguities.}
  \end{subfigure}
  \caption{\label{fig:acg-comp} Diagrams of systems of ACGs.}
\end{figure}


\section{Systems of ACGs}
\label{sec:acg-comp}

An ACG is defined in terms of two higher-order signatures, sets of typed
constants on which we can form well-typed lambda terms, and a
translating function from terms of one of the signatures to terms of the
other (the former signature being called the \emph{abstract signature},
the latter being called the \emph{object signature} and the function
being called a \emph{lexicon}). We are then interested in the terms of
the abstract signature having some distinguished type and their images
through the lexicon (these two sets of terms are called the
\emph{abstract language} and the \emph{object language}, respectively).

When describing languages, we are usually interested in systems of more than
one ACG, and diagrams such as the ones on Figure~\ref{fig:acg-comp} have been
used to explain them.

In Figure~\ref{fig:acg-comp-basic}, abstract syntactic terms from the
signature $\Sigma_{Synt}$ yield phonological strings and semantic
representations using two different lexicons. In
Figure~\ref{fig:acg-comp-constr}, this pattern is extended by adding a
new abstract signature which narrows the language of syntactic terms and
implements some linguistic constraint
\cite{pogodalla2012controlling}. Finally, in
Figure~\ref{fig:acg-comp-sem}, the abstract signature $\Sigma_{Synt}$ of
Figure~\ref{fig:acg-comp-basic} is split into two signatures,
$\Sigma_{Syntax}$ and $\Sigma_{SyntSem}$, in order to model syntactic
and semantic ambiguities in different grammars
\cite{pogodalla2007generalizing}.


\section{The Problem of Multiple Constraints}
\label{sec:constraints}

We will consider several linguistic constraints that have been given
formal treatments in grammatical formalisms.

In French, negation is signalled by prepending the particle \emph{ne} to the
negated verb in conjunction with using a properly placed accompanying word,
such as a negative determiner, in one of the verb's arguments. This phenomenon
has been elegantly formalized in the Frigram interaction grammar
\cite{perrier2007french}.

\begin{exe}
  \ex \label{ex:aucun-shallow} Jean \textbf{ne} parle à \textbf{aucun} collègue. \\
      (Jean speaks to no colleague.)
  \ex \label{ex:aucun-deep-obj} Jean \textbf{ne} parle à la femme d'\textbf{aucun} collègue. \\
      (Jean speaks to the wife of no colleague.)
  \ex \label{ex:aucun-deep-subj} \textbf{Aucun} collègue de Jean \textbf{ne} parle à sa femme. \\
      (No colleague of Jean's speaks to his wife.)
\end{exe}

We see here that the negative determiner \emph{aucun} can be present in
the subject or the object of the negated verb and it can modify the
argument directly or be attached to one of its complements. Furthermore,
we note that omitting either the word \emph{ne} or the word \emph{aucun}
while keeping the other produces a sentence which is considered
ungrammatical.

This difference in syntactic behavior between noun phrases that contain a
negative determiner and those that do not has implications for our
grammar. Since two terms that have an identical type in an ACG signature can
be freely interchanged in any sentence, we are forced to assign two different
types to these two different kinds of noun phrases.

% NOTE: We could use a single constant for the two paired words.
% NOTE: We could use a higher-order type for the negative determiner
% which demands the negative particle itself.

This leads us to a grammar in which we subdivide the atomic types $N$
and $NP$ into subtypes that reflect whether or not they contain a
negative determiner inside. Types of the other constants, such as the
preposition \emph{de} seen in (\ref{ex:aucun-deep-obj}) and
(\ref{ex:aucun-deep-subj}), will constrain their arguments to have
compatible features on their types and will propagate the information
carried in the features to its result type, e.g.:

\begin{align*}
N_{de_1} &: NP\_NEG{=}F \limp N\_NEG{=}F \limp N\_NEG{=}F \\
N_{de_2} &: NP\_NEG{=}F \limp N\_NEG{=}T \limp N\_NEG{=}T \\
N_{de_3} &: NP\_NEG{=}T \limp N\_NEG{=}F \limp N\_NEG{=}T
\end{align*}

In the above, we elaborate the types $NP$ and $N$ with features ($\_NEG{=}F$
and $\_NEG{=}T$) and we give the different types for the preposition \emph{de}
in the fragment for negation ($N$). The types accept an $NP$ and an $N$ as
arguments with any combination of values for the feature $NEG$, except for the
case when both the prepositional $NP$ and the $N$ being modified both contain
free negative determiners (i.e. there is no $N_{de_4} : NP\_NEG{=}T \limp
N\_NEG{=}T \limp N\_NEG{=}\ldots$). This encodes a constraint that there can
be only one free negative determiner per phrase (free as in not hidden inside
an embedded clause). Besides this constraint, the types also dictate how the
information about negative determiners should propagate from the argument
constituent to the complex constituent (in this case, it is simple
disjunction).

Enforcing other constraints leads us to subdividing our ``atomic'' types even
further (e.g. the authors of \cite{pogodalla2012controlling} add features to
the $S$ and $NP$ types to implement constraints about extraction). Other
phenomena, such as agreement on morphological properties like number, gender,
person or case, intuitively lead us to make our types even more specific.

If we were to use this approach to write a grammar that enforces multiple
constraints at the same time, we would end up with complicated types, like the
one below, which provide complete specifications of the various possible
situations (in this hypothetical grammar ($C$), the preposition \emph{de} has
12 different types).

\begin{align*}
C_{de_{11}} :\ &(NP\_\textcolor{red}{NEG{=}T}\_\textcolor{green}{VAR{=}F}\_\textcolor{blue}{NUM{=}PL}) \\
&\limp (N\_\textcolor{red}{NEG{=}F}\_\textcolor{blue}{NUM{=}SG}) \\
&\limp (N\_\textcolor{red}{NEG{=}T}\_\textcolor{blue}{NUM{=}SG})
\end{align*}

This creates two problems. Firstly, the number of such types grows
exponentially with the number of features added. This can be fixed by
introducing dependent types into the type system as in
\cite{de2007type}. However, while this allows us to abstract over the
combinations of feature values and write our grammar down concisely, it does
not take away the complexity. The treatments of the various linguistic
phenomena are all expressed in the same types making it hard to see whether
they are independent or not. Since the treatments cannot be considered in
isolation, reasoning about the entire grammar becomes difficult and so does
enhancing it with more constraints. This is a fatal problem for a grammar
which strives to cover a wide range of linguistic facts. We firmly believe
that simplicity is a fundamental requirement for constructing a large and
robust grammar and our proposal aims to reclaim that simplicity.

In our grammar, we would like to combine several constraints
(Figure~\ref{fig:acg-comp-constr}), and possibly to also separate the
syntactic ambiguities from the purely semantic ones
(Figure~\ref{fig:acg-comp-sem}).  However, trying to mix these strategies in
the ACG framework forces us to solve all the constraints in a single type
signature or contaminate the syntax-semantics interface with the
implementation details of the syntactic layer, both of which introduce
incidental complexity we want to avoid.

We would like to have a system which would be characterized by a diagram like
the one on Figure~\ref{fig:gacg} where the constraint signatures delimit the
legal syntactic structures independently of each other and without interfering
with the syntax-semantics interface. However, ACG diagrams are limited to
arborescences and we are obliged to generalize them in order to get
the expected interpretation of Figure~\ref{fig:gacg}.


\section{Graphical ACGs}

\begin{figure}
  \centering
  \includegraphics[height=0.3\textheight]{../diagrams/final.pdf}
  \caption{\label{fig:gacg} A graphical ACG that implements two
      independent syntactic constraints and distinguishes syntactic and
      semantic ambiguities.}
\end{figure}

We define a \emph{graphical abstract categorial grammar} as a directed acyclic
graph (DAG) whose nodes are labeled with signatures (and distinguished types)
and whose edges are labeled with lexicons, in other words a mathematical
reification of an ACG diagram that has been generalized from
arborescences to DAGs. We then search for an appropriate semantics for these
structures, i.e. how to determine what languages are defined by a graphical
ACG.

\subsection{Nodes as Languages}

We first follow a paradigm in which nodes of the diagrams are interpreted as
languages with the edges telling us how these languages are defined in terms
of each other. A single arrow leading to a language means that the target
language is produced from the source by mapping it through a lexicon. We now
argue that the suitable meaning of two or more edges arriving at the same node
is intersection of languages based both on the simplicity of the resulting
definitions and on our expectations about the desired semantics.

In an ACG diagram, a node with no inbound edges stands for an abstract
language. This language is defined as the set of terms having the correct
type. If a node has an inbound edge, and therefore a parent, then the elements
of its language are also obliged to have an antecedent in the parent
language. It is a small step to go from this definition to the following: the
language of a node is the set of terms having the correct type and an
antecedent in the language of any of its parent nodes. This correctly
characterizes the current use of ACG diagrams, recognizing abstract languages
as a special case of object languages. Furthermore, this restatement
generalizes to DAGs and gives us the desired semantics for implementing
multiple constraints: intersection.

We can formalize the above definitions by introducing the notions of
\emph{intrinsic} and \emph{extrinsic} languages associated with some node $v$
in a graphical ACG $\mathcal{G}$:

$$
\mathcal{I}_{\mathcal{G}}(v) = \{t \in \Lambda(\Sigma_v)
\mid\ \vdash_{\Sigma_v} t : S_v\}
$$
$$
\mathcal{E}_{\mathcal{G}}(v) = \mathcal{I}_{\mathcal{G}}(v) \cap
\bigcap_{(u,v) \in E} \mathcal{L}_{(u,v)}(\mathcal{E}_{\mathcal{G}}(u))
$$

The intrinsic language is just the set of terms built on the node's
signature and having the node's distinguished type. The extrinsic
language is established by taking the extrinsic languages of its
predecessors, mapping them through lexicons and taking their
intersection, or just taking the node's intrinsic language if it has no
predecessors.

We then examine the relationship between the languages defined by ACGs
and graphical ACGs (G-ACGs). Intrinsic languages correspond exactly to
abstract languages and therefore the sets of languages definable by both
are equal.

$$
\mathcal{I} = \mathcal{A}
$$

G-ACG extrinsic languages correspond to ACG object languages with
intersection. More formally, while ACG object languages are ACG abstract
languages closed on transformation by a lexicon, G-ACG extrinsic languages are
ACG abstract languages closed on transformation by a lexicon and
intersection\footnote{Can be show by induction on the topological ordering of
  any given graphical ACG.}.

$$
\mathcal{O} = \mathcal{A}^{\mathcal{L}}
$$
$$
\mathcal{E} = \mathcal{A}^{\mathcal{L}{\cap}}
$$

If we want our grammatical framework to be modular w.r.t. the different
linguistic constraints it encodes, we essentially need
intersection\footnote{If I have a grammar that enforces $A$ and a grammar that
  enforces $B$, then I want to have access to the grammar of the language
  where both $A$ and $B$ are enforced.}. Not only would we want a framework in
which intersection is possible, we would also like it to be an easy
operation. Graphical ACGs make intersections trivial to encode and as for
expressive power, we know, from the equations above, that object languages are
as expressive as extrinsic languages iff object languages are closed on
intersection (which is, at this moment, conjectured to be false). This means
that graphical ACGs are either a conservative extension providing a more
convenient way of expressing intersection or are extending ACGs by adding
only intersection, which enables constraint-based composition of grammars. 

\begin{figure}
  \centering
  \includegraphics[height=0.3\textheight]{../diagrams/diamond-grammar.pdf}
  \caption{\label{fig:diamond} The diamond-shaped G-ACG $\mathcal{D}$.}
\end{figure}

While the interpretation of G-ACGs given above does have some nice properties,
it fails to predict the intuitive understanding of more complex ACG
diagrams. This is most visible in the diamond-shaped grammar on
Figure~\ref{fig:diamond}. If we take a term from
$\mathcal{E}_{\mathcal{D}}(Bottom)$, we know it has antecedents both in
$\mathcal{E}_{\mathcal{D}}(Left)$ and
$\mathcal{E}_{\mathcal{D}}(Right)$. However, these two do not have to share an
antecedent in $\mathcal{E}_{\mathcal{D}}(Top)$. This contradicts the
generative story one might imagine in which a single term from $Top$ generates
terms in $Left$ and $Right$ which finally generate a term in $Bottom$.

We can observe another peculiarity on a more practical example. Consider the
G-ACG in Figure~\ref{fig:gacg}. In classical ACGs, one can always take an
element in a signature, like $Sem$, and by transduction find its corresponding
element in an another signature, like $Syntax$. However, in an G-ACG such as
this it is possible that the $Syntax$ term we obtain by transduction does not
belong to $\mathcal{E}_{\mathcal{G}}(Syntax)$ because it lacks antecedents in
either $Constr_1$ or $Constr_2$. This means that the notion of an extrinsic
language is not capable to give us the set of all meaning terms in $Sem$ which
actually correspond to syntactically correct sentences in this G-ACG.

The above characteristics motivated us to explore alternative interpretations
of G-ACGs. We will present one such alternative now, which exchanges the
language-algebraic point of view for a generative one.

\subsection{Nodes as Terms}

In the new paradigm, we interpret the nodes of the graph as terms and the
edges as statements that one term is mapped into another using a lexicon. This
leads us to the definition of the \emph{pangraphical}\footnote{As opposed to
  extrinsic languages, which are constrained only by their predecessors in the
  graph, pangraphical languages are constrained by the entire graph.} language
of a node $u$ in a G-ACG $\mathcal{G}$.

A term $t$ belongs to $\mathcal{P}_{\mathcal{G}}(u)$ whenever there
exists a labeling $T$ of the nodes of the graph such that:

\begin{itemize}
  \item $T_u = t$.
  \item For all $v \in V(G)$, $\vdash_{\Sigma_v} T_v : S_v$.
  \item For all $(v,w) \in E(G)$, $\mathcal{L}_{(v,w)}(T_v) = T_w$.
\end{itemize}

If we compare this new interpretation of G-ACGs to the former one, we find out
that in the case when the graph of the grammar is an arborescence they are
actually equivalent. This means that in classical ACGs, where all the diagrams
are arborescences, the two metaphors (nodes as languages and nodes as terms)
can be and are used interchangeably. However, as we start to consider
non-arborescent graphs, we find, interestingly, that the two paradigms diverge
(i.e. $\exists \mathcal{G}, u.\ \mathcal{E}_{\mathcal{G}}(u) \neq
\mathcal{P}_{\mathcal{G}}(u)$).

The newly defined pangraphical languages solve the problem of extrinsic
languages giving us counter-intuitive interpretations for some specific
G-ACGs. Specifically, the members of $\mathcal{P}_{\mathcal{D}}(Bottom)$ in
the diamond grammar have a single antecedent in
$\mathcal{P}_{\mathcal{D}}(Top)$ and the language
$\mathcal{P}_{\mathcal{G}}(Sem)$ (from Figure~\ref{fig:gacg}) contains only
meanings expressible by syntactically correct sentences.

Pangraphical languages turn out to be at least as expressive as the extrinsic
languages\footnote{This might come as no surprise given the extended domain of
  constraints compared to extrinsic languages (constrained by the entire graph
  as opposed to just the node's predecessors).}. The proof is carried out by
transforming a G-ACG such that a particular node will have the same
pangraphical language in the latter G-ACG as the extrinsic language it had in
the former. The nodes of the newly constructed G-ACG correspond to paths in
the former one terminating in the node in question\footnote{This means that
  when the G-ACG is $\mathcal{D}$, the diamond grammar, and the node in
  question is $Bottom$, then we will have two different nodes for the two
  paths $[Top, Left, Bottom]$ and $[Top, Right, Bottom]$.}. Thus the labelling
of nodes with terms which certifies a given term's presence in the
pangraphical language of the new G-ACG also serves as a proof of its presence
in the extrinsic language of the old G-ACG.

This gives us the following ladder of expressivity

$$
\mathcal{I} \subseteq \mathcal{E} \subseteq \mathcal{P}
$$

which can be complemented with the following series

$$
\mathcal{I}_{\mathcal{G}}(u) \supseteq \mathcal{E}_{\mathcal{G}}(u) \supseteq
\mathcal{P}_{\mathcal{G}}(u)
$$


\section{Example Grammar}

Finally, we construct a G-ACG which integrates the French negation constraint
discussed in Section~\ref{sec:constraints}, the constraints on extraction
introduced in \cite{pogodalla2012controlling} and a constraint handling
agreement in a single grammar specification. The constraints are implemented
exactly as they were originally described. The underlying syntactic signature
is defined without any concern for the additional constraints and the
syntax-semantics interface is kept simple as well.


\section{Conclusion}

We have considered the problem of building a wide-coverage ACG, specifically
the problem of expressing a multitude of linguistic constraints. We have
examined previous techniques and found no satisfying solution. We have thus
provided an extension of the ACG formalism to solve the problem and justified
the need for the increased expressivity. This embedding of syntactic
constraints will be used to define a syntax-semantics interface and then to
build discourse structures.

In the end, this lets us define the syntax in a clean way using the idiomatic
style of categorial grammars (simple atomic types like $N$, $NP$ and $S$) and
then define the constraints themselves the same way as they are defined in
papers which try to formalize them individually (such as is the case with
\cite{pogodalla2012controlling}).

%
% ---- Bibliography ----
%

\bibliographystyle{splncs}
\bibliography{../biblio}

\end{document}
